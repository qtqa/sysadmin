#!/usr/bin/env perl
package QtQA::App::PulseLogSync;
use strict;
use warnings;
use v5.8;

=head1 NAME

publish_log_hook - synchronize build logs from Pulse CI server to some other host

=head1 SYNOPSIS

Set Pulse build hooks:

  post-stage:
    publish_log_hook --mode post-stage --ssh-dest-host <something> --ssh-dest-path <something> \
        --build-dir "$(build.dir)" --build-number "$(build.number)" --project "$(project)" \
        --stage "$(stage)" --stage-status "$(stage.status)" --stage-dir "$(stage.dir)"

  post-build:
    publish_log_hook --mode post-stage --ssh-dest-host <something> --ssh-dest-path <something> \
        --build-dir "$(build.dir)" --build-number "$(build.number)" --project "$(project)" \
        --build-status "$(status)"

And enjoy the synchronization of the logs :)

The following structure is used for logs on the remote host:

  <base>/$(project)/$(build.number)/$(stage)/log.txt.gz
   => gzip-compressed stage log.

  <base>/$(project)/latest
   => symlink to the latest completed build of this project.

  <base>/$(project)/latest-success
   => symlink to the latest successful build of this project.

Project/stage names will have some "unfriendly" characters replaced with _
(e.g. whitespace).  Build number may be zero-padded for improved sorting.

=head2 OPTIONS

=over

=item B<--help>

Print this help.

=item B<--verbose>

Be verbose (mainly for debugging).

=item B<--mode> MODE

Mode of operation for this script; must be one of:

=over

=item B<post-stage>

Use this when invoking the script as part of a post-stage hook.
This will copy the log for this stage (only).

=item B<post-build>

Use this when invoking the script as part of a post-build hook.
This will finalize the logs for this build (e.g., setting up the `latest' and
`latest-success' symlinks on the remote host).

=back

=item B<--build-dir> DIR

The path to the build directory on the Pulse server.
The build logs are expected to be found under this directory.

=item B<--project> PROJ

The name of the Pulse project (human-readable, as shown in the Pulse UI).
This is used to decide the synchronization path on the remote host.

=item B<--build-number> NUM

The path to the build directory on the Pulse server.
This is used to decide the synchronization path on the remote host.

=item B<--build-status> STATUS [post-build only]

The status of the build (e.g. "success", "terminated").

=item B<--stage> STAGE [post-stage only]

The stage name (e.g. "linux-g++-32 Ubuntu 10.04 x86").

=item B<--stage-status> STATUS [post-stage only]

The status of the stage (e.g. "success", "terminated").

=item B<--stage-dir> DIR [post-stage only]

The path to the stage directory on the Pulse master.

=item B<--ssh-dest-host> USER@HOST

Destination username and host (or just host, if username is configured
in $HOME/.ssh/config) for synchronization.  Passwordless ssh must be
available.

=item B<--ssh-dest-path> PATH

Top-level directory on the destination host for synchronization.

=back

=cut

use Data::Dumper;
use Carp qw(confess);
use File::Basename;
use File::Path;
use File::Spec::Functions;
use Getopt::Long;
use Pod::Usage;
use IO::File;

sub new
{
    my ($class) = @_;
    return bless {}, $class;
}

# Print to STDERR iff verbose.
sub printv
{
    my ($self, @stuff) = @_;

    if ($self->{ verbose }) {
        print STDERR @stuff;
    }

    return;
}

# Parse all command-line arguments, and die if mandatory
# arguments are not set.
sub parse_args
{
    my ($self, @args) = @_;

    local @ARGV = @args;

    GetOptions(
        'help|?' => sub { pod2usage(2) },
        'mode=s' => \$self->{ mode },
        'verbose' => \$self->{ verbose },
        'build-dir=s' => \$self->{ build_dir },
        'build-number=i' => \$self->{ build_number },
        'build-status=s' => \$self->{ build_status },
        'project=s' => \$self->{ project },
        'stage=s' => \$self->{ stage },
        'stage-dir=s' => \$self->{ stage_dir },
        'stage-status=s' => \$self->{ stage_status },
        'ssh-dest-host=s' => \$self->{ ssh_dest_host },
        'ssh-dest-path=s' => \$self->{ ssh_dest_path },
    ) || die $!;

    $self->check_mandatory_args( 'mode' );
    $self->check_mandatory_args( 'project' );
    $self->check_mandatory_args( 'build-dir' );
    $self->check_mandatory_args( 'build-number' );
    $self->check_mandatory_args( 'ssh-dest-host' );
    $self->check_mandatory_args( 'ssh-dest-path' );

    return;
}

# Given a list of args, die if they are not all defined.
sub check_mandatory_args
{
    my ($self, @args) = @_;

    foreach my $arg (@args) {
        my $internal_arg = $arg;
        $internal_arg =~ s{\-}{_}g;
        if (! exists $self->{ $internal_arg }) {
            die "missing mandatory parameter: --$arg";
        }
    }

    return;
}

# Given a string, returns a copy of that string with any filesystem-unsafe
# characters (including whitespace) replaced with underscore.
sub make_safe_for_path
{
    my ($self, $path) = @_;

    $path =~ s{[^a-zA-Z0-9_.\-+]}{_}g;
    return $path;
}

# Given a build number, format it suitable for usage in a path.
# Numbers are 0-padded so that they sort nicely, and prefixed with `build_'.
# Example input: 12
# Example output: build_00012
sub format_build_number_for_path
{
    my ($self, $number) = @_;

    return sprintf( 'build_%05d', $number );
}

# Run the post-stage hook.
sub run_post_stage
{
    my ($self) = @_;

    $self->check_mandatory_args( 'stage', 'stage-dir', 'stage-status' );

    # Source file.
    my $src = catfile( $self->{ stage_dir }, 'recipe.log' );

    # Build up the destination directory.
    # We keep the path components separately for use later.
    my @dest_dir_components =  (
        $self->{ ssh_dest_path },
        $self->make_safe_for_path( $self->{ project } ),
        $self->format_build_number_for_path( $self->{ build_number } ),
        $self->make_safe_for_path( $self->{ stage } ),
    );

    # All directories between the base ssh_dest_path and the ultimate destination dir.
    # For example, if we are writing to /var/www/testresults/ci/Project/123/stage/log.txt.gz,
    # this will contain:
    #
    #   /var/www/testresults/ci
    #   /var/www/testresults/ci/Project
    #   /var/www/testresults/ci/Project/123
    #   /var/www/testresults/ci/Project/123/stage
    #
    my @dest_intermediate_dirs;
    for my $i (0..$#dest_dir_components) {
        push @dest_intermediate_dirs, catfile( @dest_dir_components[0..$i] );
    }

    # Destination directory and file.
    my $dest_dir = $dest_intermediate_dirs[-1];
    my $dest_file = catfile( $dest_dir, 'log.txt.gz' );

    # Destination file used while upload is in progress (for atomicity)
    my $dest_file_tmp = catfile( $dest_dir, '.uploading-log.txt.gz' );

    $self->printv( "src: $src\ndest: $dest_file\ndest tmp: $dest_file_tmp\n" );

    # Common part of ssh command.
    my @ssh_base = ('ssh', '-oBatchMode=yes', $self->{ ssh_dest_host });

    # The recipe log may or may not already be compressed,
    # depending on when the hook is run, and the Pulse server settings.
    my $already_compressed = 0;

    my $srcfh = new IO::File;
    if ($srcfh->open( $src, '<' )) {
        $self->printv( "opened $src [not compressed]\n");
    }
    elsif ($srcfh->open( "$src.gz", '<' )) {
        $src .= '.gz';
        $already_compressed = 1;
        $self->printv( "opened $src [compressed]\n");
    }
    else {
        confess "internal error: neither $src nor $src.gz exists";
    }

    # Command to run on the remote host.
    # The command will receive the log data on stdin.
    # Note we do this as a single command to avoid opening more ssh connections
    # than necessary.
    my $remote_cmd =
        # Make the directory on remote host
        "mkdir -p $dest_dir </dev/null"

        # Either write directly, or write with compression, to the temp dest file
       ." && ".($already_compressed ? 'cat' : 'gzip --to-stdout')." > $dest_file_tmp"

        # Then move the temp dest file into place (near-atomic)
       ." && mv $dest_file_tmp $dest_file"

        # Touch all intermediate directories, so that modified timestamp can be
        # used to make meaningful judgments about CI activity.
       ." && touch @dest_intermediate_dirs"
    ;

    my @ssh_cmd = (@ssh_base, $remote_cmd);
    $self->printv( "@ssh_cmd\n" );

    my $destfh;
    open( $destfh, '|-', @ssh_cmd ) || confess "run @ssh_cmd: $!";
    while (my $line = <$srcfh>) {
        print $destfh $line;
    }
    close( $srcfh ) || confess( "close $src: $!" );
    close( $destfh ) || confess( $! ? "close pipe to @ssh_cmd: $!" : "@ssh_cmd exited with status $?" );

    $self->printv( "Write completed.\n" );
    return;
}

# Run the post-build hook.
sub run_post_build
{
    my ($self) = @_;

    $self->check_mandatory_args( 'build-status' );

    # Project directory on remote host
    my $remote_project_dir = catfile(
        $self->{ ssh_dest_path },
        $self->make_safe_for_path( $self->{ project } ),
    );

    # Build directory on remote host
    my $remote_build_dir = catfile(
        $remote_project_dir,
        $self->format_build_number_for_path( $self->{ build_number } ),
    );

    # Links to create
    my @remote_links = (
        catfile( $remote_project_dir, 'latest' )
    );
    if ($self->{ build_status } eq 'success') {
        push @remote_links, catfile( $remote_project_dir, 'latest-success' );
    }

    $self->printv( "remote build dir: $remote_build_dir\nlinks: @remote_links\n" );

    # Common part of ssh command.
    my @ssh_base = ('ssh', '-oBatchMode=yes', $self->{ ssh_dest_host });

    my $remote_cmd = join(' && ',
        # Make sure the build dir actually exists, or something went wrong.
        "test -d $remote_build_dir",
        map( { "ln -sfT $remote_build_dir $_" } @remote_links ),
    );

    my @ssh_cmd = (@ssh_base, $remote_cmd);
    $self->printv( "@ssh_cmd\n" );

    my $status = system( @ssh_cmd );
    if ($status != 0) {
        confess "@ssh_cmd exited with status $?";
    }

    return;
}

sub run
{
    my ($self, @args) = @_;

    $self->parse_args( @args );

    $self->printv( "running: ".Dumper( $self ) );

    if ($self->{ mode } eq 'post-build') {
        return $self->run_post_build( );
    }
    if ($self->{ mode } eq 'post-stage') {
        return $self->run_post_stage( );
    }

    die "unknown mode $self->{ mode }";
}

QtQA::App::PulseLogSync->new( )->run( @ARGV ) unless caller;
1;
